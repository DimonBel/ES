\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx} % Allows you to insert figures
\usepackage{subcaption}
\usepackage{amsmath} % Allows you to do equations
\usepackage{fancyhdr} % Formats the header
\usepackage{geometry} % Formats the paper size, orientation, and margins
\usepackage{dirtytalk} % typesetting different types of quotation
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{caption}
\usepackage{float}     % in preamble, for [H] placement
\usepackage{booktabs}   % For nicer tables
\usepackage{tikz}       % For diagrams
\usetikzlibrary{shapes,arrows,positioning}

% Code styling
\lstset{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{lightgray!20},
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    extendedchars=false,
    keepspaces=true,
    morekeywords={void, size, setup, draw, pushMatrix, popMatrix}
}

\linespread{1.25} % About 1.5 spacing in Word
\setlength{\parindent}{0.8cm} % No paragraph indents
\setlength{\parskip}{0em} % Paragraphs separated by one line
\renewcommand{\headrulewidth}{0pt} % Removes line in header
\geometry{a4paper, portrait, margin=1in}
\setlength{\headheight}{14.49998pt}
\graphicspath{ {img/} }

\begin{document}
\begin{titlepage}
	\begin{center}
		\textsc{\large Ministry of Education of Republic of Moldova}\\[0.5cm]
		\textsc{\large Technical University of Moldova}\\[0.5cm]
		\textsc{\large Faculty of Computers, Informatics and Microelectronics}\\[0.5cm]
		\textsc{\large Department of Physics}\\[1.2cm]

		\vspace{25 mm}

		\textsc{\Large Embedded Systems}\\[0.5cm]
		\textsc{\large Laboratory work \#1}\\[0.5cm]

		\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
		\vspace{10 mm}
		\HRule \\[0.4cm]
		{ \LARGE \bfseries Development of a Dual-LED Control System with STDIO Serial Interface}\\[0.4cm]
		\HRule \\[1.5cm]

		\vspace{10mm}

		\begin{minipage}[t]{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Author:} \\
				Dmitrii \textsc{Belih}\\
				std. gr. FAF-232
			\end{flushleft}
		\end{minipage}
		~
		\begin{minipage}[t]{0.4\textwidth}
			\begin{flushright} \large
				\emph{Verified:} \\
				\textsc{Martiniuc} A.\\
			\end{flushright}
		\end{minipage}\\[3cm]

		\vspace{5 mm}
		\large Chișinău 2026\\[0.5cm]

		\vfill
	\end{center}
\end{titlepage}

\setcounter{page}{2}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{FAF-232 Belih Dmitrii; Laboratory Work 1}

% ============================================================================
% CHAPTER 1: DOMAIN ANALYSIS
% ============================================================================
\section*{1. Domain Analysis}

\subsection*{1.1. Purpose of the Laboratory Work}

The purpose of this laboratory work is to understand the basic principles of serial communication, learn to use the STDIO (Standard Input/Output) library for interaction with users, and develop a dual-LED control system on an embedded system platform. The work involves setting up the development environment, understanding the hardware-software interface, implementing a command parser for serial input, and creating a system that responds to text commands to control two LEDs independently or simultaneously. The system demonstrates the power of STDIO abstraction by using familiar C functions (\texttt{printf}, \texttt{getchar}) to handle serial communication, making embedded programming more accessible and maintainable.

\subsection*{1.2. Technologies Used}

\subsubsection*{Standard Input/Output (STDIO)}

Standard Input/Output (STDIO) is a standardized library mechanism for handling input and output operations in programming languages. In embedded systems, STDIO provides an abstraction layer that allows developers to interact with the system through formatted text input and output. The STDIO library typically includes functions such as \texttt{printf()} for formatted output and \texttt{scanf()} for formatted input. In embedded applications, STDIO is often redirected to a serial interface (UART), enabling communication between the microcontroller and a host computer via a terminal application.

\subsubsection*{Serial Communication (UART)}

Universal Asynchronous Receiver-Transmitter (UART) is a hardware communication protocol used for asynchronous serial communication. UART converts parallel data from the microcontroller into serial data for transmission and vice versa. It requires only two signal lines (TX for transmission and RX for reception) plus ground, making it ideal for connecting embedded systems to computers or other devices. UART communication is characterized by configurable parameters such as baud rate (typically 9600, 115200, etc.), data bits (usually 8), parity bits, and stop bits.

\subsubsection*{GPIO (General Purpose Input/Output)}

General Purpose Input/Output (GPIO) pins are configurable digital pins on microcontrollers that can be programmed as either inputs or outputs. When configured as inputs, GPIO pins can read the state of external devices such as buttons, switches, or sensors. When configured as outputs, they can drive external components such as LEDs, relays, or other digital interfaces. GPIO pins often include internal pull-up or pull-down resistors to ensure stable logic levels when external components are not actively driving the pin.

\subsubsection*{Arduino Platform}

Arduino is an open-source electronics platform based on easy-to-use hardware and software. It provides a simplified development environment and a rich set of libraries that abstract away many low-level hardware details. The Arduino platform includes various microcontroller boards (such as Arduino Uno, Arduino Mega 2560, etc.), an Integrated Development Environment (IDE), and a comprehensive software framework. Arduino boards are widely used in education, prototyping, and hobby projects due to their accessibility and extensive community support.

\subsection*{1.3. Hardware Components}

\subsubsection*{Arduino Uno}

The Arduino Uno is a microcontroller board based on the ATmega328P AVR microcontroller. It features 14 digital input/output pins (of which 6 can be used as PWM outputs), 6 analog inputs, a 16 MHz crystal oscillator, a USB connection, a power jack, an ICSP header, and a reset button. The ATmega328P has 32 KB of flash memory for storing code, 2 KB of SRAM, and 1 KB of EEPROM. The board operates at 5V and can be powered via USB or an external power supply (7-12V).

\subsubsection*{LED (Light Emitting Diode)}

A Light Emitting Diode (LED) is a semiconductor light source that emits light when current flows through it. LEDs are polarized components, meaning they must be connected in the correct orientation. Typically, an LED requires a forward voltage drop of approximately 1.8V to 3.3V (depending on color) and a forward current of 20 mA for optimal brightness. To limit the current and prevent damage to both the LED and the microcontroller, a current-limiting resistor must be used in series with the LED. For a 5V supply and a typical LED with 2V forward voltage, a 150-220 ohm resistor is appropriate.

\subsection*{1.4. Software Components}

\subsubsection*{Arduino IDE}

The Arduino Integrated Development Environment (IDE) is a cross-platform application written in Java that provides a simplified programming environment for Arduino boards. It includes a code editor with syntax highlighting, a compiler based on GCC, a library manager, and tools for uploading code to the microcontroller. The Arduino IDE supports C++ programming with a simplified API that includes functions such as \texttt{digitalWrite()}, \texttt{digitalRead()}, \texttt{analogRead()}, and \texttt{Serial} methods for serial communication.

\subsubsection*{PlatformIO}

PlatformIO is an open-source ecosystem for embedded development that integrates with various code editors (including VS Code). It provides advanced features such as intelligent code completion, multi-platform build systems, library management, unit testing, and debugging capabilities. PlatformIO supports a wide range of development boards and frameworks, making it a powerful alternative to the Arduino IDE for more complex projects.

\subsection*{1.5. System Architecture and Justification}

The system architecture follows a layered approach that separates hardware abstraction, driver implementation, and application logic:

\begin{itemize}
    \item \textbf{Hardware Layer:} Consists of the Arduino Uno microcontroller, two LEDs, and UART serial interface. The microcontroller provides GPIO pins and UART hardware for communication.

    \item \textbf{Hardware-Software Interface (Driver Layer):} This layer implements drivers for hardware components. The LED driver provides functions to turn LEDs on and off, while the serial driver abstracts the UART hardware and provides STDIO functions.

    \item \textbf{Application Layer:} Implements the main application logic, responding to serial commands and controlling the LEDs accordingly. The application uses STDIO for user communication, providing status messages and receiving commands.

    \item \textbf{STDIO Service Layer:} Provides formatted input/output capabilities by redirecting STDIO functions to the serial interface, enabling communication with a terminal application on a host computer.
\end{itemize}

This architecture was chosen because it promotes modularity, reusability, and separation of concerns. Each layer has a well-defined responsibility, making the code easier to understand, maintain, and extend. The use of STDIO for serial communication simplifies user interaction and leverages familiar I/O functions from standard programming.

\subsection*{1.6. Case Study: Interactive Embedded Systems}

Interactive embedded systems are widely used in consumer electronics, industrial control, and IoT applications. For example, a smart home lighting system typically allows users to control multiple lights through a mobile app or voice commands. The system receives text or voice commands, parses them, and sends control signals to individual lights. This is analogous to our dual-LED control system, where text commands via serial interface control individual LEDs or groups of LEDs.

Another example is an industrial machine control interface that accepts commands through a terminal or HMI (Human-Machine Interface). Operators type commands to start, stop, or configure machinery, and the system provides status feedback through LEDs and text responses. The command parsing and LED control techniques implemented in this laboratory work are fundamental building blocks for such systems.

The STDIO approach used here is particularly valuable because it allows embedded systems to use familiar I/O functions (\texttt{printf}, \texttt{scanf}, \texttt{getchar}) that abstract away the details of serial communication. This abstraction layer makes embedded code more readable, portable, and easier to develop for programmers who are experienced with standard C programming.

% ============================================================================
% CHAPTER 2: DESIGN
% ============================================================================
\section*{2. Design}

\subsection*{2.1. Architectural Sketch}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{architecture-diagram.jpg}
    \caption{System Architecture}
    \label{fig:architecture}
\end{figure}

\textbf{Architecture Components:}

\begin{itemize}
    \item \textbf{User (Serial Terminal Input):} User interacts with the system through a serial terminal, entering text commands to control the LEDs.

    \item \textbf{Serial STDIO Module (Input/Output):} Handles communication between the microcontroller and the terminal, redirecting standard C I/O functions (\texttt{printf}, \texttt{getchar}) to the serial interface.

    \item \textbf{Command Parser Module (Processing):} Interprets user commands, performing text processing (trimming whitespace, case conversion) and matching against known command patterns.

    \item \textbf{LED Module (Hardware Control):} Controls the physical LEDs based on parsed commands, managing GPIO pins and providing visual feedback.
\end{itemize}


\subsection*{2.3. Functional Block Diagrams}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{block-diagram.jpg}
    \caption{Application Logic Flowchart}
    \label{fig:app-flowchart}
\end{figure}

\textbf{Application Algorithm:}

\begin{enumerate}
    \item \textbf{Start:} Begin program execution.
    \item \textbf{Prompt User for Input:} Display prompt and wait for user input via serial interface.
    \item \textbf{User Input Valid?:} Check if input is valid (not empty, proper format).
        \begin{itemize}
            \item \textbf{No:} Return to prompt user for input.
            \item \textbf{Yes:} Proceed to next step.
        \end{itemize}
    \item \textbf{Clear Input Buffer:} Clear any remaining characters in the input buffer.
    \item \textbf{Trim Whitespace from Input:} Remove leading and trailing whitespace characters.
    \item \textbf{input == 'led on'?:} Check if input matches "led on" command.
        \begin{itemize}
            \item \textbf{Yes:} Turn LED on, then return to prompt user for input.
            \item \textbf{No:} Proceed to next check.
        \end{itemize}
    \item \textbf{input == 'led off'?:} Check if input matches "led off" command.
        \begin{itemize}
            \item \textbf{Yes:} Turn LED off, then return to prompt user for input.
            \item \textbf{No:} Display user input (unknown command), then return to prompt user for input.
        \end{itemize}
\end{enumerate}

The system uses a continuous loop that prompts for input, validates it, processes it through command matching, and provides appropriate feedback. This interactive approach allows for real-time LED control through a simple command-line interface.

\subsection*{2.4. Electrical Schematic}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{electric.jpg}
    \caption{Electrical Schematic}
    \label{fig:schematic}
\end{figure}

\textbf{Circuit Description:}

\subsubsection*{LED1 Circuit:}

\begin{itemize}
    \item \textbf{Connection:} LED1 anode (positive terminal) is connected to Pin 9 of the Arduino through a 220 ohm current-limiting resistor. LED1 cathode (negative terminal) is connected to ground (GND).

    \item \textbf{Current Calculation:} With a 5V supply, 2V forward voltage drop across the LED, and 220 ohm resistor, the current is: $I = (5V - 2V) / 220\Omega = 13.6 mA$, which is within the safe operating range for both the LED and the Arduino GPIO pin (maximum 40 mA per pin).

    \item \textbf{Operation:} When Pin 9 is set HIGH (5V), current flows from the pin through the resistor and LED1 to ground, causing the LED to light up. When Pin 9 is set LOW (0V), no current flows and the LED is off.
\end{itemize}

\subsubsection*{LED2 Circuit:}

\begin{itemize}
    \item \textbf{Connection:} LED2 anode (positive terminal) is connected to Pin 13 of the Arduino through a 220 ohm current-limiting resistor. LED2 cathode (negative terminal) is connected to ground (GND).

    \item \textbf{Current Calculation:} Same as LED1: $I = (5V - 2V) / 220\Omega = 13.6 mA$.

    \item \textbf{Operation:} When Pin 13 is set HIGH (5V), LED2 lights up. When Pin 13 is set LOW (0V), LED2 is off. Note that Pin 13 also has an onboard LED connected to it, so LED2 status can be observed both on the breadboard and the Arduino board.
\end{itemize}

\subsection*{2.5. Project Structure}

The project follows a modular structure where each hardware component is represented by separate header (.h) and implementation (.cpp) files:

\begin{verbatim}
ES/
|-- src/
|   |-- main.cpp                          # Main application logic
|   `-- modules/
|       |-- led/
|       |   |-- led.h                     # LED driver interface
|       |   `-- led.cpp                   # LED driver implementation
|       |-- command/
|       |   |-- command.h                 # Command parser interface
|       |   `-- command.cpp               # Command parser implementation
|       `-- serial_stdio/
|           |-- serial_stdio.h            # STDIO serial interface
|           `-- serial_stdio.cpp          # STDIO implementation
|-- platformio.ini                        # PlatformIO configuration
`-- lib/                                  # Additional libraries (if any)
\end{verbatim}

\textbf{Module Descriptions:}

\subsubsection*{LED Module (led.h / led.cpp)}

\textbf{Interface (led.h):}
\begin{itemize}
    \item \texttt{Led::Led(uint8\_t pin):} Constructor that initializes the LED with the specified GPIO pin.
    \item \texttt{void Led::begin():} Configures the GPIO pin as output and initializes LED state to off.
    \item \texttt{void Led::on():} Turns the LED on by setting the GPIO pin to HIGH.
    \item \texttt{void Led::off():} Turns the LED off by setting the GPIO pin to LOW.
    \item \texttt{void Led::toggle():} Toggles the LED state (on to off, off to on).
    \item \texttt{bool Led::state() const:} Returns the current LED state (true = on, false = off).
\end{itemize}

\textbf{Implementation (led.cpp):}
The LED driver uses Arduino's \texttt{pinMode()} function to configure the GPIO pin as output and \texttt{digitalWrite()} to control the pin state. The driver maintains an internal state variable to track the current LED status.

\subsubsection*{Command Module (command.h / command.cpp)}

\textbf{Interface (command.h):}
\begin{itemize}
    \item \texttt{enum CommandType:} Enumeration of supported commands (LED1\_ON, LED1\_OFF, LED2\_ON, LED2\_OFF, BOTH\_ON, BOTH\_OFF, UNKNOWN, EMPTY).
    \item \texttt{static CommandType CommandParser::parse(const char* input):} Parses a text string and returns the corresponding command type.
    \item \texttt{static bool CommandParser::isValid(CommandType cmd):} Checks if a command type is valid.
    \item \texttt{static const char* CommandParser::toString(CommandType cmd):} Converts a command type to its string representation.
\end{itemize}

\textbf{Implementation (command.cpp):}
The command parser implements text processing functions including whitespace trimming and case conversion. It compares the processed input string against known command patterns and returns the appropriate command type. The parser is case-insensitive and handles leading/trailing whitespace gracefully.

\subsubsection*{Serial STDIO Module (serial\_stdio.h / serial\_stdio.cpp)}

\textbf{Interface (serial\_stdio.h):}
\begin{itemize}
    \item \texttt{static void SerialStdio::begin(unsigned long baudRate):} Initializes serial communication and redirects stdout/stdin to the serial port.
    \item \texttt{static void SerialStdio::printWelcome():} Prints the welcome message and available commands.
    \item \texttt{static int SerialStdio::readLine(char* buffer, int bufferSize):} Reads a line of text from serial input until newline character.
\end{itemize}

\textbf{Implementation (serial\_stdio.cpp):}
The STDIO module uses AVR-libc's file stream functions (\texttt{fdev\_setup\_stream}) to redirect standard C I/O functions (\texttt{printf}, \texttt{getchar}) to the Arduino's Serial port. This allows the use of familiar C library functions for serial communication. The module handles character echoing for backspace and provides line buffering.

\subsubsection*{Main Application (main.cpp)}

\textbf{Setup:}
\begin{itemize}
    \item Initialize serial communication at 9600 baud with STDIO redirection.
    \item Initialize LED1 on Pin 9 and LED2 on Pin 13.
    \item Print welcome message with available commands.
\end{itemize}

\textbf{Main Loop:}
\begin{itemize}
    \item Read a line of text input from serial interface.
    \item Parse the input string to determine the command type.
    \item Print debug information showing the received command.
    \item Execute the command by controlling the appropriate LEDs.
    \item Print confirmation message indicating the result.
    \item Repeat indefinitely.
\end{itemize}

The application demonstrates the integration of command parsing, LED control, and STDIO for user interaction, following the layered architecture design.

% ============================================================================
% CHAPTER 3: RESULTS
% ============================================================================
\section*{3. Results}

\subsection*{3.1. System Operation}

The dual-LED control system was successfully implemented and tested. The system responds to text commands via the serial interface, controlling two LEDs independently or simultaneously. The STDIO abstraction allows the use of familiar C functions (\texttt{printf}, \texttt{getchar}) for serial communication, demonstrating the power and simplicity of this approach.

\subsection*{3.2. Serial Interface Output}

The following output was captured from the serial interface during system operation:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img/console.jpg}
    \caption{Serial Interface Console Output}
    \label{fig:console-output}
\end{figure}

\textbf{Output Analysis:}

The system initializes successfully with welcome message and available commands. Commands are parsed and executed with debug feedback showing received input and confirmation messages. The "led both on" command demonstrates sequential activation with 500ms delay between LEDs. Empty input is handled gracefully.

\subsection*{3.3. System Screenshots}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/1led-on.jpg}
    \caption{System Running with Both LEDs On}
    \label{fig:screenshot-led1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/2led-on.jpg}
    \caption{System Running with Both LEDs On (Alternate View)}
    \label{fig:screenshot-led2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/led-off.jpg}
    \caption{System Running with Both LEDs Off}
    \label{fig:screenshot-off}
\end{figure}

\textbf{Screenshot Analysis:}

Figures \ref{fig:screenshot-led1} and \ref{fig:screenshot-led2} show both LEDs illuminated (yellow LED1 and red LED2) after executing "led both on" command. Figure \ref{fig:screenshot-off} shows both LEDs off. The Arduino board is powered and operational, with LEDs connected through 220$\Omega$ resistors on a breadboard.

\subsection*{3.4. Hardware Montage}

The hardware montage shows:
\begin{itemize}
    \item Arduino Uno development board (or compatible)
    \item Two LEDs connected to Pins 9 (LED1 - yellow/orange) and 13 (LED2 - red)
    \item Two 220 ohm current-limiting resistors
    \item Breadboard for prototyping connections
    \item Multicolored jumper wires for connections
    \item USB cable for power and serial communication to the host computer
\end{itemize}

The setup demonstrates a clean, modular approach to embedded systems prototyping, with clear separation between the microcontroller, passive components (LEDs, resistors), and interconnections.


% ============================================================================
% CHAPTER 4: CONCLUSIONS
% ============================================================================
\section*{4. Conclusions}

\subsection*{4.1. Performance Analysis}

The dual-LED control system demonstrated reliable operation. Command response is immediate with efficient parsing (case-insensitive, whitespace handling). Serial communication at 9600 baud proved stable with successful STDIO redirection. LED control is reliable with no flickering. Memory usage is minimal (~4KB flash, 300 bytes RAM). Modular design with separate modules for LED, command parsing, and serial STDIO ensures maintainability.

\subsection*{4.2. Limitations and Identified Issues}

\begin{itemize}
    \item \textbf{Blocking I/O:} System waits for user input, preventing concurrent tasks or background processing.
    \item \textbf{Limited Command Set:} Only six basic commands; no status queries, PWM brightness control, or sequences.
    \item \textbf{No Error Recovery:} Minimal error handling for invalid commands or hardware failures.
    \item \textbf{No State Persistence:} LED states not saved across power cycles.
    \item \textbf{Fixed Baud Rate:} Hardcoded to 9600 baud.
    \item \textbf{No Authentication:} Accepts commands from any source without access control.
\end{itemize}

\subsection*{4.4. Knowledge Gained}

Gained practical experience with PlatformIO environment, embedded system architecture, GPIO control, serial communication with STDIO redirection, command parsing with text processing, modular code design, debugging via serial output, AVR-libc file stream functions, and abstraction layer benefits.

\subsection*{4.5. Real-World Applications}

Techniques apply to smart home lighting systems, industrial machine controllers, network equipment configuration consoles, automotive diagnostic tools, medical equipment interfaces, and IoT gateways. The foundational concepts—GPIO control, serial communication, command parsing, STDIO abstraction, and modular design—are essential for embedded systems engineering.

% ============================================================================
% CHAPTER 5: AI TOOLS USAGE
% ============================================================================
\section*{5. Note on AI Tools Usage}

During the preparation of this report, the author utilized ChatGPT (an AI language model developed by OpenAI) for generating and consolidating content. The AI assistance was used for:

\begin{itemize}
    \item Generating and structuring technical descriptions of hardware components and technologies.
    \item Formulating explanations of system architecture and design decisions.
    \item Drafting sections on domain analysis and case studies.
    \item Suggesting improvements and limitations based on the implemented solution.
    \item Assisting with formatting and organizing the report structure.
\end{itemize}

All information generated by the AI tool was reviewed, validated, and adjusted by the author to ensure accuracy, relevance, and compliance with the laboratory work requirements. The author takes full responsibility for the content presented in this report.

% ============================================================================
% CHAPTER 6: BIBLIOGRAPHY
% ============================================================================
\section*{6. Bibliography}

\begin{enumerate}
    \item Arduino.cc. \textit{Arduino Language Reference}. Available: \url{https://www.arduino.cc/reference/en/} [Accessed: 2026-02-08].

    \item Atmel Corporation. \textit{ATmega328P Datasheet - Complete}. 2014. Available: \url{https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328P_Datasheet.pdf} [Accessed: 2026-02-08].

    \item PlatformIO. \textit{PlatformIO Documentation}. Available: \url{https://docs.platformio.org/} [Accessed: 2026-02-08].

    \item Axelson, J. \textit{Serial Port Complete: COM Ports, USB Virtual COM Ports, and Ports for Embedded Systems}. Lakeview Research, 2007.

    \item Arduino.cc. \textit{Serial Communication}. Available: \url{https://www.arduino.cc/reference/en/language/functions/communication/serial/} [Accessed: 2026-02-08].
\end{enumerate}

% ============================================================================
% CHAPTER 7: APPENDIX - SOURCE CODE
% ============================================================================
\section*{7. Appendix - Source Code}

\subsection*{7.1. LED Driver Header (led.h)}

\begin{lstlisting}[language=C++, caption=led.h - LED Driver Interface]
#ifndef LED_H
#define LED_H

#include <Arduino.h>

class Led
{
public:
\texplicit Led(uint8_t pin);
	void begin();
	void on();
	void off();
	void toggle();
	bool state() const;

private:
	uint8_t _pin;
	bool _state;
};

#endif // LED_H
\end{lstlisting}

\subsection*{7.2. LED Driver Implementation (led.cpp)}

\begin{lstlisting}[language=C++, caption=led.cpp - LED Driver Implementation]
#include "led.h"

Led::Led(uint8_t pin)
    : _pin(pin), _state(false) {}

void Led::begin()
{
  pinMode(_pin, OUTPUT);
  digitalWrite(_pin, LOW);
  _state = false;
}

void Led::on()
{
  digitalWrite(_pin, HIGH);
  _state = true;
}

void Led::off()
{
  digitalWrite(_pin, LOW);
  _state = false;
}

void Led::toggle()
{
  if (_state)
    off();
  else
    on();
}

bool Led::state() const { return _state; }
\end{lstlisting}

\subsection*{7.3. Command Parser Header (command.h)}

\begin{lstlisting}[language=C++, caption=command.h - Command Parser Interface]
#ifndef COMMAND_H
#define COMMAND_H

#include <Arduino.h>

enum CommandType {
    CMD_LED1_ON,
    CMD_LED1_OFF,
    CMD_LED2_ON,
    CMD_LED2_OFF,
    CMD_BOTH_ON,
    CMD_BOTH_OFF,
    CMD_UNKNOWN,
    CMD_EMPTY
};

class CommandParser {
public:
    static CommandType parse(const char* input);

    static bool isValid(CommandType cmd);

    static const char* toString(CommandType cmd);

private:
    static const int MAX_CMD_LENGTH = 32;
};

#endif // COMMAND_H
\end{lstlisting}

\subsection*{7.4. Command Parser Implementation (command.cpp)}

\begin{lstlisting}[language=C++, caption=command.cpp - Command Parser Implementation]
#include "command.h"
#include <string.h>
#include <ctype.h>

static void trimWhitespace(char* str) {
    char* end;

    while (isspace((unsigned char)*str)) str++;

    if (*str == 0) {
        *str = 0;
        return;
    }

    end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end)) end--;

    *(end + 1) = 0;
}

static void toLowerCase(char* str) {
    for (; *str; ++str) {
        *str = tolower((unsigned char)*str);
    }
}

CommandType CommandParser::parse(const char* input) {
    if (input == nullptr || input[0] == '\0') {
        return CMD_EMPTY;
    }

    char buffer[MAX_CMD_LENGTH];
    strncpy(buffer, input, MAX_CMD_LENGTH - 1);
    buffer[MAX_CMD_LENGTH - 1] = '\0';

    trimWhitespace(buffer);
    toLowerCase(buffer);

    if (strcmp(buffer, "led1 on") == 0) {
        return CMD_LED1_ON;
    } else if (strcmp(buffer, "led1 off") == 0) {
        return CMD_LED1_OFF;
    } else if (strcmp(buffer, "led2 on") == 0) {
        return CMD_LED2_ON;
    } else if (strcmp(buffer, "led2 off") == 0) {
        return CMD_LED2_OFF;
    } else if (strcmp(buffer, "led both on") == 0) {
        return CMD_BOTH_ON;
    } else if (strcmp(buffer, "led both off") == 0) {
        return CMD_BOTH_OFF;
    }

    return CMD_UNKNOWN;
}

bool CommandParser::isValid(CommandType cmd) {
    return (cmd >= CMD_LED1_ON && cmd <= CMD_BOTH_OFF) || cmd == CMD_EMPTY;
}

const char* CommandParser::toString(CommandType cmd) {
    switch (cmd) {
        case CMD_LED1_ON:      return "led1 on";
        case CMD_LED1_OFF:     return "led1 off";
        case CMD_LED2_ON:      return "led2 on";
        case CMD_LED2_OFF:     return "led2 off";
        case CMD_BOTH_ON:      return "led both on";
        case CMD_BOTH_OFF:     return "led both off";
        case CMD_EMPTY:        return "(empty)";
        case CMD_UNKNOWN:
        default:               return "unknown";
    }
}
\end{lstlisting}

\subsection*{7.5. Serial STDIO Header (serial\_stdio.h)}

\begin{lstlisting}[language=C++, caption=serial_stdio.h - Serial STDIO Interface]
#ifndef SERIAL_STDIO_H
#define SERIAL_STDIO_H

#include <Arduino.h>

class SerialStdio {
public:
    static void begin(unsigned long baudRate);

    static void printWelcome();

    static int readLine(char* buffer, int bufferSize);

public:
    static const int LINE_BUF_SIZE = 80;

private:
    static int serialPutchar(char c, FILE* stream);

    static int serialGetchar(FILE* stream);

    static FILE serial_stdout;
    static FILE serial_stdin;
};

#endif // SERIAL_STDIO_H
\end{lstlisting}

\subsection*{7.6. Serial STDIO Implementation (serial\_stdio.cpp)}

\begin{lstlisting}[language=C++, caption=serial_stdio.cpp - Serial STDIO Implementation]
#include "serial_stdio.h"
#include <stdio.h>

FILE SerialStdio::serial_stdout;
FILE SerialStdio::serial_stdin;

void SerialStdio::begin(unsigned long baudRate) {
    Serial.begin(baudRate);

    fdev_setup_stream(&serial_stdout, serialPutchar, NULL, _FDEV_SETUP_WRITE);
    fdev_setup_stream(&serial_stdin, NULL, serialGetchar, _FDEV_SETUP_READ);
    stdout = &serial_stdout;
    stdin = &serial_stdin;
}

void SerialStdio::printWelcome() {
    printf("STDIO serial ready. Commands: 'led1 on', 'led1 off', 'led2 on', 'led2 off'\n");
    printf("                           'led both on', 'led both off'\n");
}

int SerialStdio::readLine(char* buffer, int bufferSize) {
    int pos = 0;

    while (true) {
        int c = getchar();

        if (c == '\r' || c == '\n') {
            buffer[pos] = '\0';
            return pos;
        }

        if (c == '\b' || c == 127) {
            if (pos > 0) {
                pos--;
            }
            continue;
        }

        if (c >= 32 && c <= 126 && pos < bufferSize - 1) {
            buffer[pos++] = (char)c;
        }
    }
}

int SerialStdio::serialPutchar(char c, FILE* stream) {
    if (c == '\n') Serial.write('\r');
    Serial.write(c);
    return 0;
}

int SerialStdio::serialGetchar(FILE* stream) {
    while (!Serial.available());
    int c = Serial.read();

    if (c == '\b' || c == 127) {
        Serial.write("\b \b");
        return c;
    }

    return c;
}
\end{lstlisting}

\subsection*{7.7. Main Application (main.cpp)}

\begin{lstlisting}[language=C++, caption=main.cpp - Main Application]
#include <Arduino.h>
#include "serial_stdio/serial_stdio.h"
#include "command/command.h"
#include "led/led.h"

static const unsigned long SERIAL_BAUD_RATE = 9600;
static const uint8_t LED1_PIN = 9;
static const uint8_t LED2_PIN = 13;

static Led led1(LED1_PIN);
static Led led2(LED2_PIN);

static void executeCommand(CommandType cmd)
{
  switch (cmd)
  {
  case CMD_LED1_ON:
    led1.on();
    printf("OK: LED1 is ON\n");
    break;

  case CMD_LED1_OFF:
    led1.off();
    printf("OK: LED1 is OFF\n");
    break;

  case CMD_LED2_ON:
    led2.on();
    printf("OK: LED2 is ON\n");
    break;

  case CMD_LED2_OFF:
    led2.off();
    printf("OK: LED2 is OFF\n");
    break;

  case CMD_BOTH_ON:
    led1.on();
    printf("OK: LED1 is ON (starting sequence)\n");
    delay(500);
    led2.on();
    printf("OK: LED2 is ON (sequence complete)\n");
    break;

  case CMD_BOTH_OFF:
    led1.off();
    led2.off();
    printf("OK: Both LEDs are OFF\n");
    break;

  case CMD_EMPTY:
    break;

  case CMD_UNKNOWN:
  default:
    printf("ERR: Unknown command\n");
    break;
  }
}

void setup()
{
  SerialStdio::begin(SERIAL_BAUD_RATE);

  led1.begin();
  led2.begin();

  SerialStdio::printWelcome();
}

void loop()
{
  char line[SerialStdio::LINE_BUF_SIZE];

  SerialStdio::readLine(line, sizeof(line));

  CommandType cmd = CommandParser::parse(line);

  printf("DEBUG: Received '%s' -> %s\n",
         line,
         CommandParser::toString(cmd));

  executeCommand(cmd);
}
\end{lstlisting}

\pagebreak
\end{document}