\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx} % Allows you to insert figures
\usepackage{subcaption}
\usepackage{amsmath} % Allows you to do equations
\usepackage{fancyhdr} % Formats the header
\usepackage{geometry} % Formats the paper size, orientation, and margins
\usepackage{dirtytalk} % typesetting different types of quotation
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{caption}
\usepackage{float}     % in preamble, for [H] placement
\usepackage{booktabs}   % For nicer tables
\usepackage{tikz}       % For diagrams
\usetikzlibrary{shapes,arrows,positioning}

% Code styling
\lstset{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{lightgray!20},
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    extendedchars=false,
    keepspaces=true,
    morekeywords={void, size, setup, draw, pushMatrix, popMatrix}
}

\linespread{1.25} % About 1.5 spacing in Word
\setlength{\parindent}{0.8cm} % No paragraph indents
\setlength{\parskip}{0em} % Paragraphs separated by one line
\renewcommand{\headrulewidth}{0pt} % Removes line in header
\geometry{a4paper, portrait, margin=1in}
\setlength{\headheight}{14.49998pt}
\graphicspath{ {img/} }

\begin{document}
\begin{titlepage}
	\begin{center}
		\textsc{\large Ministry of Education of Republic of Moldova}\\[0.5cm]
		\textsc{\large Technical University of Moldova}\\[0.5cm]
		\textsc{\large Faculty of Computers, Informatics and Microelectronics}\\[0.5cm]
		\textsc{\large Department of Physics}\\[1.2cm]

		\vspace{25 mm}

		\textsc{\Large Embedded Systems}\\[0.5cm]
		\textsc{\large Laboratory work \#1}\\[0.5cm]

		\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
		\vspace{10 mm}
		\HRule \\[0.4cm]
		{ \LARGE \bfseries Development of a Dual-LED Control System with STDIO Serial Interface}\\[0.4cm]
		\HRule \\[1.5cm]

		\vspace{10mm}

		\begin{minipage}[t]{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Author:} \\
				Dmitrii \textsc{Belih}\\
				std. gr. FAF-232
			\end{flushleft}
		\end{minipage}
		~
		\begin{minipage}[t]{0.4\textwidth}
			\begin{flushright} \large
				\emph{Verified:} \\
				\textsc{Martiniuc} A.\\
			\end{flushright}
		\end{minipage}\\[3cm]

		\vspace{5 mm}
		\large Chișinău 2026\\[0.5cm]

		\vfill
	\end{center}
\end{titlepage}

\setcounter{page}{2}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{FAF-232 Belih Dmitrii; Laboratory Work 1}

% ============================================================================
% CHAPTER 1: DOMAIN ANALYSIS
% ============================================================================
\section*{1. Domain Analysis}

\subsection*{1.1. Purpose of the Laboratory Work}

The purpose of this laboratory work is to understand the basic principles of serial communication, learn to use the STDIO (Standard Input/Output) library for interaction with users, and develop a dual-LED control system on an embedded system platform. The work involves setting up the development environment, understanding the hardware-software interface, implementing a command parser for serial input, and creating a system that responds to text commands to control two LEDs independently or simultaneously. The system demonstrates the power of STDIO abstraction by using familiar C functions (\texttt{printf}, \texttt{getchar}) to handle serial communication, making embedded programming more accessible and maintainable.

\subsection*{1.2. Technologies Used}

\subsubsection*{Standard Input/Output (STDIO)}

Standard Input/Output (STDIO) is a standardized library mechanism for handling input and output operations in programming languages. In embedded systems, STDIO provides an abstraction layer that allows developers to interact with the system through formatted text input and output. The STDIO library typically includes functions such as \texttt{printf()} for formatted output and \texttt{scanf()} for formatted input. In embedded applications, STDIO is often redirected to a serial interface (UART), enabling communication between the microcontroller and a host computer via a terminal application.

\subsubsection*{Serial Communication (UART)}

Universal Asynchronous Receiver-Transmitter (UART) is a hardware communication protocol used for asynchronous serial communication. UART converts parallel data from the microcontroller into serial data for transmission and vice versa. It requires only two signal lines (TX for transmission and RX for reception) plus ground, making it ideal for connecting embedded systems to computers or other devices. UART communication is characterized by configurable parameters such as baud rate (typically 9600, 115200, etc.), data bits (usually 8), parity bits, and stop bits.

\subsubsection*{GPIO (General Purpose Input/Output)}

General Purpose Input/Output (GPIO) pins are configurable digital pins on microcontrollers that can be programmed as either inputs or outputs. When configured as inputs, GPIO pins can read the state of external devices such as buttons, switches, or sensors. When configured as outputs, they can drive external components such as LEDs, relays, or other digital interfaces. GPIO pins often include internal pull-up or pull-down resistors to ensure stable logic levels when external components are not actively driving the pin.

\subsubsection*{Arduino Platform}

Arduino is an open-source electronics platform based on easy-to-use hardware and software. It provides a simplified development environment and a rich set of libraries that abstract away many low-level hardware details. The Arduino platform includes various microcontroller boards (such as Arduino Uno, Arduino Mega 2560, etc.), an Integrated Development Environment (IDE), and a comprehensive software framework. Arduino boards are widely used in education, prototyping, and hobby projects due to their accessibility and extensive community support.

\subsection*{1.3. Hardware Components}

\subsubsection*{Arduino Mega 2560}

The Arduino Mega 2560 is a microcontroller board based on the ATmega2560 AVR microcontroller. It features 54 digital input/output pins (of which 15 can be used as PWM outputs), 16 analog inputs, 4 UARTs (hardware serial ports), a 16 MHz crystal oscillator, a USB connection, a power jack, an ICSP header, and a reset button. The ATmega2560 has 256 KB of flash memory for storing code, 8 KB of SRAM, and 4 KB of EEPROM. The board operates at 5V and can be powered via USB or an external power supply (7-12V).

\subsubsection*{LED (Light Emitting Diode)}

A Light Emitting Diode (LED) is a semiconductor light source that emits light when current flows through it. LEDs are polarized components, meaning they must be connected in the correct orientation. Typically, an LED requires a forward voltage drop of approximately 1.8V to 3.3V (depending on color) and a forward current of 20 mA for optimal brightness. To limit the current and prevent damage to both the LED and the microcontroller, a current-limiting resistor must be used in series with the LED. For a 5V supply and a typical LED with 2V forward voltage, a 150-220 ohm resistor is appropriate.

\subsubsection*{Push Button}

A push button is a momentary contact switch that completes an electrical circuit when pressed and breaks it when released. In digital circuits, push buttons are typically connected to GPIO pins configured as inputs. To ensure stable logic levels, buttons are often used with pull-up or pull-down resistors (internal or external). When using an internal pull-up resistor, the button connects the pin to ground when pressed (reading LOW) and the resistor pulls the pin to VCC when released (reading HIGH). Mechanical switches exhibit contact bounce, where the signal oscillates briefly when pressed or released, requiring debouncing either in hardware or software.

\subsection*{1.4. Software Components}

\subsubsection*{Arduino IDE}

The Arduino Integrated Development Environment (IDE) is a cross-platform application written in Java that provides a simplified programming environment for Arduino boards. It includes a code editor with syntax highlighting, a compiler based on GCC, a library manager, and tools for uploading code to the microcontroller. The Arduino IDE supports C++ programming with a simplified API that includes functions such as \texttt{digitalWrite()}, \texttt{digitalRead()}, \texttt{analogRead()}, and \texttt{Serial} methods for serial communication.

\subsubsection*{PlatformIO}

PlatformIO is an open-source ecosystem for embedded development that integrates with various code editors (including VS Code). It provides advanced features such as intelligent code completion, multi-platform build systems, library management, unit testing, and debugging capabilities. PlatformIO supports a wide range of development boards and frameworks, making it a powerful alternative to the Arduino IDE for more complex projects.

\subsection*{1.5. System Architecture and Justification}

The system architecture follows a layered approach that separates hardware abstraction, driver implementation, and application logic:

\begin{itemize}
    \item \textbf{Hardware Layer:} Consists of the Arduino Mega 2560 microcontroller, LED, push button, and UART serial interface. The microcontroller provides GPIO pins and UART hardware for communication.

    \item \textbf{Hardware-Software Interface (Driver Layer):} This layer implements drivers for hardware components. The LED driver provides functions to turn the LED on and off, while the button driver provides functions to read the button state with debouncing. The serial driver abstracts the UART hardware and provides STDIO functions.

    \item \textbf{Application Layer:} Implements the main application logic, responding to button presses and controlling the LED accordingly. The application uses STDIO for user communication, providing status messages and receiving commands.

    \item \textbf{STDIO Service Layer:} Provides formatted input/output capabilities by redirecting STDIO functions to the serial interface, enabling communication with a terminal application on a host computer.
\end{itemize}

This architecture was chosen because it promotes modularity, reusability, and separation of concerns. Each layer has a well-defined responsibility, making the code easier to understand, maintain, and extend. The use of STDIO for serial communication simplifies user interaction and leverages familiar I/O functions from standard programming.

\subsection*{1.6. Case Study: Interactive Embedded Systems}

Interactive embedded systems are widely used in consumer electronics, industrial control, and IoT applications. For example, a smart home lighting system typically allows users to control multiple lights through a mobile app or voice commands. The system receives text or voice commands, parses them, and sends control signals to individual lights. This is analogous to our dual-LED control system, where text commands via serial interface control individual LEDs or groups of LEDs.

Another example is an industrial machine control interface that accepts commands through a terminal or HMI (Human-Machine Interface). Operators type commands to start, stop, or configure machinery, and the system provides status feedback through LEDs and text responses. The command parsing and LED control techniques implemented in this laboratory work are fundamental building blocks for such systems.

The STDIO approach used here is particularly valuable because it allows embedded systems to use familiar I/O functions (\texttt{printf}, \texttt{scanf}, \texttt{getchar}) that abstract away the details of serial communication. This abstraction layer makes embedded code more readable, portable, and easier to develop for programmers who are experienced with standard C programming.

% ============================================================================
% CHAPTER 2: DESIGN
% ============================================================================
\section*{2. Design}

\subsection*{2.1. Architectural Sketch}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm,
        auto,
        block/.style={
            rectangle,
            draw=black,
            thick,
            fill=blue!10,
            text width=5em,
            align=center,
            rounded corners,
            minimum height=3em
        },
        hw/.style={
            rectangle,
            draw=black,
            thick,
            fill=red!10,
            text width=5em,
            align=center,
            rounded corners,
            minimum height=3em
        },
        line/.style={
            draw,
            thick,
            -latex',
            shorten >=2pt
        }
    ]
        % Hardware
        \node[hw] (led1) {LED1};
        \node[hw, right=of led1] (led2) {LED2};
        \node[hw, below=of led1, xshift=2cm] (uart) {UART};

        % Drivers
        \node[block, above=of led1] (led1Driver) {LED1\\Driver};
        \node[block, above=of led2] (led2Driver) {LED2\\Driver};
        \node[block, above=of uart] (serialDriver) {Serial\\Driver};

        % Services
        \node[block, above=of led1Driver, xshift=2cm] (stdioService) {STDIO\\Service};
        \node[block, above=of stdioService, text width=6em] (cmdParser) {Command\\Parser};

        % Application
        \node[block, above=of cmdParser, text width=7em] (app) {Application\\Logic};

        % Host
        \node[hw, above=of serialDriver, xshift=3cm] (terminal) {Terminal\\(PC)};

        % Connections
        \path[line] (app) -- (cmdParser);
        \path[line] (cmdParser) -- (stdioService);
        \path[line] (stdioService) -- (serialDriver);
        \path[line] (serialDriver) -- (uart);
        \path[line] (terminal) -- (serialDriver);

        \path[line] (app) -| (led1Driver);
        \path[line] (app) -| (led2Driver);
        \path[line] (led1Driver) -- (led1);
        \path[line] (led2Driver) -- (led2);

        % Labels
        \node[above=0.1cm of led1Driver, font=\tiny] {Pin 9};
        \node[above=0.1cm of led2Driver, font=\tiny] {Pin 13};
        \node[left=0.1cm of serialDriver, font=\tiny] {TX/RX};
    \end{tikzpicture}
    \caption{System Architecture}
    \label{fig:architecture}
\end{figure}

\textbf{Architecture Components:}

\begin{itemize}
    \item \textbf{Application Logic:} Main application that reads serial input, parses commands, and controls LEDs accordingly. Coordinates between command parser and LED drivers.

    \item \textbf{Command Parser:} Parses text input from serial interface and converts it to command types. Handles case-insensitive parsing and whitespace trimming.

    \item \textbf{STDIO Service:} Redirects standard I/O functions (\texttt{printf}, \texttt{getchar}) to the serial interface, enabling formatted text communication using familiar C functions.

    \item \textbf{Serial Driver:} Handles UART communication, including configuration (9600 baud), data transmission, and reception. Provides low-level serial access.

    \item \textbf{UART:} Hardware serial interface that enables communication with the host computer via USB.

    \item \textbf{Terminal (PC):} Terminal application on the host computer that displays serial output and accepts user text commands.

    \item \textbf{LED1 Driver:} Controls LED1 connected to Pin 9. Provides functions to turn the LED on, off, or toggle.

    \item \textbf{LED2 Driver:} Controls LED2 connected to Pin 13. Provides functions to turn the LED on, off, or toggle.

    \item \textbf{LED1:} First light-emitting diode that provides visual feedback for command execution.

    \item \textbf{LED2:} Second light-emitting diode that provides visual feedback for command execution.
\end{itemize}

\subsection*{2.2. Hardware-Software Interface Diagrams}

\subsubsection*{LED Hardware-Software Interface}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.2cm,
        auto,
        block/.style={
            rectangle,
            draw=black,
            thick,
            fill=blue!10,
            text width=4em,
            align=center,
            rounded corners,
            minimum height=2.5em
        },
        hw/.style={
            rectangle,
            draw=black,
            thick,
            fill=red!10,
            text width=4em,
            align=center,
            rounded corners,
            minimum height=2.5em
        },
        line/.style={
            draw,
            thick,
            -latex',
            shorten >=2pt
        }
    ]
        \node[block] (app) {Application};
        \node[block, right=of app] (parser) {Command\\Parser};
        \node[block, right=of parser] (service) {LED\\Service};
        \node[block, right=of service] (driver) {LED\\Driver};
        \node[block, right=of driver] (gpio) {GPIO\\Module};
        \node[hw, right=of gpio] (led) {LED};

        \path[line] (app) -- (parser);
        \path[line] (parser) -- (service);
        \path[line] (service) -- node[below, font=\tiny] {On/Off Command} (driver);
        \path[line] (driver) -- node[below, font=\tiny] {Logic Level} (gpio);
        \path[line] (gpio) -- node[below, font=\tiny] {Voltage} (led);
    \end{tikzpicture}
    \caption{LED Hardware-Software Interface}
    \label{fig:led-hw-sw}
\end{figure}

\textbf{Component Roles:}

\begin{itemize}
    \item \textbf{Application:} Main program logic that processes serial input, determines LED control commands based on parsed input, and coordinates LED operations.

    \item \textbf{Command Parser:} Converts text commands (e.g., "led1 on") into enumerated command types that the application can process efficiently.

    \item \textbf{LED Service:} Provides high-level LED control functions, such as turning on, turning off, and toggling the LED state for both LED1 and LED2.

    \item \textbf{LED Driver:} Implements low-level LED control by writing appropriate values to GPIO registers. Handles LED-specific requirements and maintains state.

    \item \textbf{GPIO Module:} Hardware peripheral that converts digital logic levels (0/1) to physical pin voltages. Sources or sinks current to drive the LED.

    \item \textbf{LED:} Light-emitting diode that converts electrical current into visible light. Requires appropriate current limiting and proper polarity.
\end{itemize}

\subsubsection*{LED Hardware-Software Interface}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.2cm,
        auto,
        block/.style={
            rectangle,
            draw=black,
            thick,
            fill=blue!10,
            text width=4em,
            align=center,
            rounded corners,
            minimum height=2.5em
        },
        hw/.style={
            rectangle,
            draw=black,
            thick,
            fill=red!10,
            text width=4em,
            align=center,
            rounded corners,
            minimum height=2.5em
        },
        line/.style={
            draw,
            thick,
            -latex',
            shorten >=2pt
        }
    ]
        \node[block] (app) {Application};
        \node[block, right=of app] (service) {LED\\Service};
        \node[block, right=of service] (driver) {LED\\Driver};
        \node[block, right=of driver] (gpio) {GPIO\\Module};
        \node[hw, right=of gpio] (led) {LED};

        \path[line] (app) -- (service);
        \path[line] (service) -- node[below, font=\tiny] {On/Off Command} (driver);
        \path[line] (driver) -- node[below, font=\tiny] {Logic Level} (gpio);
        \path[line] (gpio) -- node[below, font=\tiny] {Voltage} (led);
    \end{tikzpicture}
    \caption{LED Hardware-Software Interface}
    \label{fig:led-hw-sw}
\end{figure}

\textbf{Component Roles:}

\begin{itemize}
    \item \textbf{Application:} Main program logic that determines when the LED should be on or off based on button events and other conditions.

    \item \textbf{LED Service:} Provides high-level LED control functions, such as turning on, turning off, and toggling the LED state.

    \item \textbf{LED Driver:} Implements low-level LED control by writing appropriate values to GPIO registers. Handles LED-specific requirements such as PWM for brightness control if needed.

    \item \textbf{GPIO Module:} Hardware peripheral that converts digital logic levels (0/1) to physical pin voltages. Sources or sinks current to drive the LED.

    \item \textbf{LED:} Light-emitting diode that converts electrical current into visible light. Requires appropriate current limiting and proper polarity.
\end{itemize}

\subsubsection*{Serial Interface Hardware-Software Interface}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.2cm,
        auto,
        block/.style={
            rectangle,
            draw=black,
            thick,
            fill=blue!10,
            text width=4em,
            align=center,
            rounded corners,
            minimum height=2.5em
        },
        hw/.style={
            rectangle,
            draw=black,
            thick,
            fill=red!10,
            text width=4em,
            align=center,
            rounded corners,
            minimum height=2.5em
        },
        line/.style={
            draw,
            thick,
            -latex',
            shorten >=2pt
        }
    ]
        \node[block] (app) {Application};
        \node[block, right=of app] (stdio) {STDIO\\Service};
        \node[block, right=of stdio] (driver) {Serial\\Driver};
        \node[block, right=of driver] (uart) {UART\\Peripheral};
        \node[hw, above=of uart] (terminal) {Terminal\\(PC)};
        \node[hw, right=of uart] (usb) {USB-to-\\Serial};

        \path[line] (app) -- (stdio);
        \path[line] (stdio) -- node[below, font=\tiny] {Formatted I/O} (driver);
        \path[line] (driver) -- node[below, font=\tiny] {TX/RX Data} (uart);
        \path[line] (terminal) -- node[left, font=\tiny] {Serial} (uart);
        \path[line] (uart) -- node[below, font=\tiny] {USB} (usb);
    \end{tikzpicture}
    \caption{Serial Interface Hardware-Software Interface}
    \label{fig:serial-hw-sw}
\end{figure}

\textbf{Component Roles:}

\begin{itemize}
    \item \textbf{Application:} Uses standard I/O functions (printf, scanf) for user communication without needing to know the underlying communication mechanism.

    \item \textbf{STDIO Service:} Redirects standard I/O operations to the serial interface. Provides buffering and formatting for efficient communication.

    \item \textbf{Serial Driver:} Implements UART communication protocol, including configuration (baud rate, data bits, etc.), transmission, and reception of data.

    \item \textbf{UART Peripheral:} Hardware module that converts parallel data from the microcontroller to serial data for transmission and vice versa. Handles timing and signal generation.

    \item \textbf{Terminal (PC):} Application running on the host computer that displays serial output and accepts user input. Examples include PuTTY, Arduino Serial Monitor, and minicom.

    \item \textbf{USB-to-Serial:} Converts USB signals from the computer to UART signals for the microcontroller. Built into Arduino boards.
\end{itemize}

\subsection*{2.3. Functional Block Diagrams}

\subsubsection*{Command Parser Block Diagram}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=0.8cm,
        auto,
        block/.style={
            rectangle,
            draw=black,
            thick,
            fill=green!10,
            text width=5em,
            align=center,
            rounded corners,
            minimum height=2em
        },
        decision/.style={
            diamond,
            draw=black,
            thick,
            fill=yellow!10,
            text width=4em,
            align=center,
            aspect=2
        },
        line/.style={
            draw,
            thick,
            -latex',
            shorten >=2pt
        }
    ]
        \node[block] (start) {Start};
        \node[block, below=of start] (input) {Read Input\\String};
        \node[decision, below=of input] (empty) {Empty?};
        \node[block, below=of empty, xshift=-2cm] (trim) {Trim\\Whitespace};
        \node[block, below=of trim] (lower) {Convert to\\Lowercase};
        \node[decision, below=of lower] (led1on) {"led1 on"?};
        \node[decision, below=of led1on] (led1off) {"led1 off"?};
        \node[decision, below=of led1off] (led2on) {"led2 on"?};
        \node[decision, below=of led2on] (led2off) {"led2 off"?};
        \node[decision, below=of led2off] (bothon) {"led both on"?};
        \node[decision, below=of bothon] (bothoff) {"led both off"?};
        \node[block, below=of bothoff, xshift=1.5cm] (unknown) {Return\\UNKNOWN};

        \node[block, right=of led1on, xshift=1cm] (ret1on) {Return\\LED1\_ON};
        \node[block, right=of led1off, xshift=1cm] (ret1off) {Return\\LED1\_OFF};
        \node[block, right=of led2on, xshift=1cm] (ret2on) {Return\\LED2\_ON};
        \node[block, right=of led2off, xshift=1cm] (ret2off) {Return\\LED2\_OFF};
        \node[block, right=of bothon, xshift=1cm] (reton) {Return\\BOTH\_ON};
        \node[block, right=of bothoff, xshift=1cm] (retoff) {Return\\BOTH\_OFF};
        \node[block, right=of empty, xshift=1cm] (retempty) {Return\\EMPTY};

        \path[line] (start) -- (input);
        \path[line] (input) -- (empty);
        \path[line] (empty) -- node[left, font=\tiny] {No} (trim);
        \path[line] (empty) -- node[right, font=\tiny] {Yes} (retempty);
        \path[line] (trim) -- (lower);
        \path[line] (lower) -- (led1on);
        \path[line] (led1on) -- node[left, font=\tiny] {No} (led1off);
        \path[line] (led1on) -- node[right, font=\tiny] {Yes} (ret1on);
        \path[line] (led1off) -- node[left, font=\tiny] {No} (led2on);
        \path[line] (led1off) -- node[right, font=\tiny] {Yes} (ret1off);
        \path[line] (led2on) -- node[left, font=\tiny] {No} (led2off);
        \path[line] (led2on) -- node[right, font=\tiny] {Yes} (ret2on);
        \path[line] (led2off) -- node[left, font=\tiny] {No} (bothon);
        \path[line] (led2off) -- node[right, font=\tiny] {Yes} (ret2off);
        \path[line] (bothon) -- node[left, font=\tiny] {No} (bothoff);
        \path[line] (bothon) -- node[right, font=\tiny] {Yes} (reton);
        \path[line] (bothoff) -- node[left, font=\tiny] {No} (unknown);
        \path[line] (bothoff) -- node[right, font=\tiny] {Yes} (retoff);
    \end{tikzpicture}
    \caption{Command Parser Flowchart}
    \label{fig:parser-flowchart}
\end{figure}

\textbf{Command Parser Algorithm:}

\begin{enumerate}
    \item \textbf{Start:} Begin command parsing operation.
    \item \textbf{Read Input String:} Read the complete line of text input from the serial interface.
    \item \textbf{Empty?} Check if the input string is empty or contains only whitespace.
    \item \textbf{Trim Whitespace:} Remove leading and trailing whitespace characters from the input string.
    \item \textbf{Convert to Lowercase:} Convert all characters in the string to lowercase for case-insensitive matching.
    \item \textbf{Match Commands:} Compare the processed string against known command patterns:
        \begin{itemize}
            \item "led1 on" $\rightarrow$ Return CMD\_LED1\_ON
            \item "led1 off" $\rightarrow$ Return CMD\_LED1\_OFF
            \item "led2 on" $\rightarrow$ Return CMD\_LED2\_ON
            \item "led2 off" $\rightarrow$ Return CMD\_LED2\_OFF
            \item "led both on" $\rightarrow$ Return CMD\_BOTH\_ON
            \item "led both off" $\rightarrow$ Return CMD\_BOTH\_OFF
        \end{itemize}
    \item \textbf{Return UNKNOWN:} If no match is found, return CMD\_UNKNOWN.
\end{enumerate}

The parser provides robust command handling by normalizing input (trimming, case conversion) before matching, making the system user-friendly and tolerant of input variations.

\subsubsection*{Application Logic Block Diagram}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=0.8cm,
        auto,
        block/.style={
            rectangle,
            draw=black,
            thick,
            fill=green!10,
            text width=5em,
            align=center,
            rounded corners,
            minimum height=2em
        },
        decision/.style={
            diamond,
            draw=black,
            thick,
            fill=yellow!10,
            text width=4em,
            align=center,
            aspect=2
        },
        line/.style={
            draw,
            thick,
            -latex',
            shorten >=2pt
        }
    ]
        \node[block] (start) {Start};
        \node[block, below=of start] (init) {Initialize\\Hardware};
        \node[block, below=of init] (print) {Print\\Welcome};
        \node[block, below=of print] (read) {Read Serial\\Line};
        \node[block, below=of read] (parse) {Parse\\Command};
        \node[decision, below=of parse] (cmdtype) {Command\\Type?};
        \node[block, below=of cmdtype, xshift=-3cm] (exec) {Execute\\Command};
        \node[block, below=of exec] (debug) {Print Debug\\Info};
        \node[block, below=of debug] (loop) {Loop};

        \node[block, right=of exec, xshift=1cm] (led1on) {LED1 ON};
        \node[block, right=of led1on] (led1off) {LED1 OFF};
        \node[block, right=of led1off] (led2on) {LED2 ON};
        \node[block, right=of led2on] (led2off) {LED2 OFF};
        \node[block, right=of led2off] (bothon) {BOTH ON\\(w/ delay)};
        \node[block, right=of bothon] (bothoff) {BOTH OFF};

        \path[line] (start) -- (init);
        \path[line] (init) -- (print);
        \path[line] (print) -- (read);
        \path[line] (read) -- (parse);
        \path[line] (parse) -- (cmdtype);
        \path[line] (cmdtype) -- (exec);
        \path[line] (exec) -- (debug);
        \path[line] (debug) -- (loop);
        \path[line] (loop.east) to[out=0,in=0] node[right, font=\tiny] {Repeat} (read.east);

        \path[line] (exec) -- (led1on);
        \path[line] (led1on) -- (led1off);
        \path[line] (led1off) -- (led2on);
        \path[line] (led2on) -- (led2off);
        \path[line] (led2off) -- (bothon);
        \path[line] (bothon) -- (bothoff);
    \end{tikzpicture}
    \caption{Application Logic Flowchart}
    \label{fig:app-flowchart}
\end{figure}

\textbf{Application Algorithm:}

\begin{enumerate}
    \item \textbf{Start:} Begin program execution.
    \item \textbf{Initialize Hardware:} Configure GPIO pins for LED1 (Pin 9) and LED2 (Pin 13) as outputs, initialize serial communication at 9600 baud.
    \item \textbf{Print Welcome:} Display welcome message and available commands via serial interface using printf.
    \item \textbf{Read Serial Line:} Wait for user input via serial interface using getchar, reading until newline character.
    \item \textbf{Parse Command:} Process the input string through the command parser to determine the command type.
    \item \textbf{Execute Command:} Based on parsed command type, perform the appropriate action:
        \begin{itemize}
            \item \textbf{LED1 ON/OFF:} Turn LED1 on or off.
            \item \textbf{LED2 ON/OFF:} Turn LED2 on or off.
            \item \textbf{BOTH ON:} Turn LED1 on, wait 500ms, then turn LED2 on (sequential activation).
            \item \textbf{BOTH OFF:} Turn both LEDs off simultaneously.
            \item \textbf{EMPTY:} Do nothing (user pressed Enter without command).
            \item \textbf{UNKNOWN:} Print error message.
        \end{itemize}
    \item \textbf{Print Debug Info:} Output debug information showing the received command and its interpretation.
    \item \textbf{Loop:} Return to step 4 to wait for next command.
\end{enumerate}

The system uses a blocking read approach, waiting for user input before processing. This is suitable for a command-line interface where the system responds to user commands rather than autonomous operation.

\subsection*{2.4. Electrical Schematic}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=2cm,
        auto,
        component/.style={
            rectangle,
            draw=black,
            thick,
            fill=white,
            minimum width=2cm,
            minimum height=1cm,
            align=center
        },
        mcu/.style={
            rectangle,
            draw=black,
            thick,
            fill=blue!10,
            minimum width=3cm,
            minimum height=4cm,
            align=center
        },
        line/.style={
            draw,
            thick
        }
    ]
        % MCU
        \node[mcu] (mcu) {Arduino};

        % Pins
        \node[below left=0.5cm and 0.2cm of mcu.north west] (led1pin) {Pin 9\\(LED1)};
        \node[below right=0.5cm and 0.2cm of mcu.north east] (led2pin) {Pin 13\\(LED2)};

        % LED1 circuit
        \node[component, below=2cm of led1pin, xshift=-1cm] (led1) {LED1};
        \node[component, right=0.5cm of led1] (res1) {Resistor\\220$\Omega$};
        \node[component, right=0.5cm of res1] (gnd1) {GND};

        % LED2 circuit
        \node[component, below=2cm of led2pin, xshift=1cm] (led2) {LED2};
        \node[component, left=0.5cm of led2] (res2) {Resistor\\220$\Omega$};
        \node[component, left=0.5cm of res2] (gnd2) {GND};

        % Connections
        \draw[line] (led1pin) -- ++(0,-0.5) -| (led1.north);
        \draw[line] (led1.south) -- (res1.north);
        \draw[line] (res1.south) -- (gnd1.north);
        \draw[line] (led2pin) -- ++(0,-0.5) -| (led2.north);
        \draw[line] (led2.south) -- (res2.north);
        \draw[line] (res2.south) -- (gnd2.north);

        % Labels
        \node[above=0.2cm of led1pin, font=\small] {GPIO Output};
        \node[above=0.2cm of led2pin, font=\small] {GPIO Output};

        % Current flow indicators
        \draw[->, red, thick] ($(led1.west)+(0,0.3)$) -- ($(led1.east)+(0,0.3)$);
        \node[above=0.1cm of led1, font=\tiny, red] {20 mA};
        \draw[->, red, thick] ($(led2.west)+(0,0.3)$) -- ($(led2.east)+(0,0.3)$);
        \node[above=0.1cm of led2, font=\tiny, red] {20 mA};
    \end{tikzpicture}
    \caption{Electrical Schematic}
    \label{fig:schematic}
\end{figure}

\textbf{Circuit Description:}

\subsubsection*{LED1 Circuit:}

\begin{itemize}
    \item \textbf{Connection:} LED1 anode (positive terminal) is connected to Pin 9 of the Arduino through a 220 ohm current-limiting resistor. LED1 cathode (negative terminal) is connected to ground (GND).

    \item \textbf{Current Calculation:} With a 5V supply, 2V forward voltage drop across the LED, and 220 ohm resistor, the current is: $I = (5V - 2V) / 220\Omega = 13.6 mA$, which is within the safe operating range for both the LED and the Arduino GPIO pin (maximum 40 mA per pin).

    \item \textbf{Operation:} When Pin 9 is set HIGH (5V), current flows from the pin through the resistor and LED1 to ground, causing the LED to light up. When Pin 9 is set LOW (0V), no current flows and the LED is off.
\end{itemize}

\subsubsection*{LED2 Circuit:}

\begin{itemize}
    \item \textbf{Connection:} LED2 anode (positive terminal) is connected to Pin 13 of the Arduino through a 220 ohm current-limiting resistor. LED2 cathode (negative terminal) is connected to ground (GND).

    \item \textbf{Current Calculation:} Same as LED1: $I = (5V - 2V) / 220\Omega = 13.6 mA$.

    \item \textbf{Operation:} When Pin 13 is set HIGH (5V), LED2 lights up. When Pin 13 is set LOW (0V), LED2 is off. Note that Pin 13 also has an onboard LED connected to it, so LED2 status can be observed both on the breadboard and the Arduino board.
\end{itemize}

\subsection*{2.5. Project Structure}

The project follows a modular structure where each hardware component is represented by separate header (.h) and implementation (.cpp) files:

\begin{lstlisting}[caption=Project Directory Structure]
ES/
├── src/
│   ├── main.cpp                          # Main application logic
│   └── modules/
│       ├── led/
│       │   ├── led.h                     # LED driver interface
│       │   └── led.cpp                   # LED driver implementation
│       ├── command/
│       │   ├── command.h                 # Command parser interface
│       │   └── command.cpp               # Command parser implementation
│       └── serial_stdio/
│           ├── serial_stdio.h            # STDIO serial interface
│           └── serial_stdio.cpp          # STDIO implementation
├── platformio.ini                        # PlatformIO configuration
└── lib/                                  # Additional libraries (if any)
\end{lstlisting}

\textbf{Module Descriptions:}

\subsubsection*{LED Module (led.h / led.cpp)}

\textbf{Interface (led.h):}
\begin{itemize}
    \item \texttt{Led::Led(uint8\_t pin):} Constructor that initializes the LED with the specified GPIO pin.
    \item \texttt{void Led::begin():} Configures the GPIO pin as output and initializes LED state to off.
    \item \texttt{void Led::on():} Turns the LED on by setting the GPIO pin to HIGH.
    \item \texttt{void Led::off():} Turns the LED off by setting the GPIO pin to LOW.
    \item \texttt{void Led::toggle():} Toggles the LED state (on to off, off to on).
    \item \texttt{bool Led::state() const:} Returns the current LED state (true = on, false = off).
\end{itemize}

\textbf{Implementation (led.cpp):}
The LED driver uses Arduino's \texttt{pinMode()} function to configure the GPIO pin as output and \texttt{digitalWrite()} to control the pin state. The driver maintains an internal state variable to track the current LED status.

\subsubsection*{Command Module (command.h / command.cpp)}

\textbf{Interface (command.h):}
\begin{itemize}
    \item \texttt{enum CommandType:} Enumeration of supported commands (LED1\_ON, LED1\_OFF, LED2\_ON, LED2\_OFF, BOTH\_ON, BOTH\_OFF, UNKNOWN, EMPTY).
    \item \texttt{static CommandType CommandParser::parse(const char* input):} Parses a text string and returns the corresponding command type.
    \item \texttt{static bool CommandParser::isValid(CommandType cmd):} Checks if a command type is valid.
    \item \texttt{static const char* CommandParser::toString(CommandType cmd):} Converts a command type to its string representation.
\end{itemize}

\textbf{Implementation (command.cpp):}
The command parser implements text processing functions including whitespace trimming and case conversion. It compares the processed input string against known command patterns and returns the appropriate command type. The parser is case-insensitive and handles leading/trailing whitespace gracefully.

\subsubsection*{Serial STDIO Module (serial\_stdio.h / serial\_stdio.cpp)}

\textbf{Interface (serial\_stdio.h):}
\begin{itemize}
    \item \texttt{static void SerialStdio::begin(unsigned long baudRate):} Initializes serial communication and redirects stdout/stdin to the serial port.
    \item \texttt{static void SerialStdio::printWelcome():} Prints the welcome message and available commands.
    \item \texttt{static int SerialStdio::readLine(char* buffer, int bufferSize):} Reads a line of text from serial input until newline character.
\end{itemize}

\textbf{Implementation (serial\_stdio.cpp):}
The STDIO module uses AVR-libc's file stream functions (\texttt{fdev\_setup\_stream}) to redirect standard C I/O functions (\texttt{printf}, \texttt{getchar}) to the Arduino's Serial port. This allows the use of familiar C library functions for serial communication. The module handles character echoing for backspace and provides line buffering.

\subsubsection*{Main Application (main.cpp)}

\textbf{Setup:}
\begin{itemize}
    \item Initialize serial communication at 9600 baud with STDIO redirection.
    \item Initialize LED1 on Pin 9 and LED2 on Pin 13.
    \item Print welcome message with available commands.
\end{itemize}

\textbf{Main Loop:}
\begin{itemize}
    \item Read a line of text input from serial interface.
    \item Parse the input string to determine the command type.
    \item Print debug information showing the received command.
    \item Execute the command by controlling the appropriate LEDs.
    \item Print confirmation message indicating the result.
    \item Repeat indefinitely.
\end{itemize}

The application demonstrates the integration of command parsing, LED control, and STDIO for user interaction, following the layered architecture design..

% ============================================================================
% CHAPTER 3: RESULTS
% ============================================================================
\section*{3. Results}

\subsection*{3.1. System Operation}

The dual-LED control system was successfully implemented and tested. The system responds to text commands via the serial interface, controlling two LEDs independently or simultaneously. The STDIO abstraction allows the use of familiar C functions (\texttt{printf}, \texttt{getchar}) for serial communication, demonstrating the power and simplicity of this approach.

\subsection*{3.2. Serial Interface Output}

The following output was captured from the serial interface during system operation:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img/console.jpg}
    \caption{Serial Interface Console Output}
    \label{fig:console-output}
\end{figure}

\textbf{Output Analysis:}

\begin{itemize}
    \item The system initializes successfully, displaying the welcome message and available commands.
    \item The header shows keyboard shortcuts for terminal control (Quit: Ctrl+C, Menu: Ctrl+T, Help: Ctrl+H).
    \item The system accepts commands for controlling LED1, LED2, or both LEDs simultaneously.
    \item Each command is echoed with debug information showing the received input and parsed command.
    \item Confirmation messages indicate the result of each command execution.
    \item The "led both on" command demonstrates sequential activation with a 500ms delay between LED1 and LED2.
    \item Empty input (pressing Enter without typing) is handled gracefully with an empty command response.
    \item The system maintains a prompt for continuous command input.
\end{itemize}

\subsection*{3.3. System Screenshots}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/1led-on.jpg}
    \caption{System Running with Both LEDs On}
    \label{fig:screenshot-led1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/2led-on.jpg}
    \caption{System Running with Both LEDs On (Alternate View)}
    \label{fig:screenshot-led2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/led-off.jpg}
    \caption{System Running with Both LEDs Off}
    \label{fig:screenshot-off}
\end{figure}

\textbf{Screenshot Analysis:}

\begin{itemize}
    \item Figure \ref{fig:screenshot-led1} shows the system with both LEDs illuminated. The yellow/orange LED (LED1) and red LED (LED2) are both on, indicating successful execution of the "led both on" command.
    \item Figure \ref{fig:screenshot-led2} provides an alternate view of the system with both LEDs active, showing the breadboard setup and Arduino board clearly.
    \item Figure \ref{fig:screenshot-off} shows the system with both LEDs off, demonstrating the "led both off" command execution.
    \item The Arduino's onboard LED (near the USB connector) is also visible, showing the board is powered and operational.
    \item The hardware setup uses a breadboard for easy prototyping, with LEDs connected through current-limiting resistors.
    \item Multicolored jumper wires provide clear visual distinction between different connections.
\end{itemize}

\subsection*{3.4. Hardware Montage}

The hardware montage shows:
\begin{itemize}
    \item Arduino Uno development board (or compatible)
    \item Two LEDs connected to Pins 9 (LED1 - yellow/orange) and 13 (LED2 - red)
    \item Two 220 ohm current-limiting resistors
    \item Breadboard for prototyping connections
    \item Multicolored jumper wires for connections
    \item USB cable for power and serial communication to the host computer
\end{itemize}

The setup demonstrates a clean, modular approach to embedded systems prototyping, with clear separation between the microcontroller, passive components (LEDs, resistors), and interconnections.

\subsection*{3.5. Video Demonstration}

A video demonstration of the system in operation is available at the following link:

\begin{center}
    \url{https://www.youtube.com/watch?v=VIDEO_ID_PLACEHOLDER}
\end{center}

\textit{Note: The video demonstrates the command-based LED control with real-time serial interface output showing command parsing and execution.}

% ============================================================================
% CHAPTER 4: CONCLUSIONS
% ============================================================================
\section*{4. Conclusions}

\subsection*{4.1. Performance Analysis}

The button-LED application demonstrated reliable operation under normal conditions. The following performance characteristics were observed:

\begin{itemize}
    \item \textbf{Response Time:} The system responds to button presses within 100ms (the polling interval). This is adequate for the intended application but could be improved with interrupt-based handling for faster response.

    \item \textbf{Debounce Effectiveness:} The software debouncing (50ms delay) successfully eliminated false triggers from contact bounce. No multiple registrations were observed for single button presses.

    \item \textbf{Serial Communication:} Serial communication at 115200 baud proved stable with no data loss or corruption observed during testing. The formatted output provided clear status information.

    \item \textbf{LED Control:} The LED turned on and off reliably with no flickering or inconsistent behavior. The 220 ohm resistor provided appropriate current limiting.

    \item \textbf{Memory Usage:} The application uses minimal memory resources, approximately 2KB of flash memory and 200 bytes of RAM, leaving ample resources for additional functionality.
\end{itemize}

\subsection*{4.2. Limitations and Identified Issues}

\begin{itemize}
    \item \textbf{Polling-Based Button Reading:} The current implementation uses polling in the main loop with a 100ms delay. While simple and reliable, this approach has limitations:
        \begin{itemize}
            \item Maximum response time is 100ms, which may be insufficient for time-critical applications.
            \item The delay blocks other operations, preventing concurrent tasks.
            \item Power consumption is higher than interrupt-based approaches due to continuous polling.
        \end{itemize}

    \item \textbf{Single Button Support:} The system currently supports only one button. Adding more buttons would require code modifications and additional GPIO pins.

    \item \textbf{No Input Validation:} The serial interface only provides output; there is no mechanism for receiving commands from the user to change system parameters or behavior.

    \item \textbf{Limited State Management:} The LED state is not persistent across power cycles. There is no mechanism to save and restore state using EEPROM or other non-volatile memory.

    \item \textbf{No Error Handling:} The application does not include error handling for potential issues such as disconnected components or communication failures.
\end{itemize}

\subsection*{4.3. Proposed Improvements}

\begin{itemize}
    \item \textbf{Interrupt-Based Button Handling:} Implement button interrupts using Arduino's \texttt{attachInterrupt()} function. This would:
        \begin{itemize}
            \item Reduce response time to microseconds instead of milliseconds.
            \item Eliminate the need for polling delays.
            \item Reduce power consumption by allowing the microcontroller to sleep when idle.
        \end{itemize}

    \item \textbf{Enhanced Serial Interface:} Add bidirectional serial communication to allow users to send commands such as:
        \begin{itemize}
            \item \texttt{LED ON} - Turn LED on
            \item \texttt{LED OFF} - Turn LED off
            \item \texttt{STATUS} - Request current system status
            \item \texttt{TOGGLE} - Toggle LED state
        \end{itemize}

    \item \textbf{Multiple Button Support:} Extend the button driver to support multiple buttons. This could be implemented as an array of button objects with individual pin assignments and state tracking.

    \item \textbf{State Persistence:} Implement state saving to EEPROM so that the LED state is preserved across power cycles. This would require using Arduino's EEPROM library.

    \item \textbf{Error Handling and Diagnostics:} Add error checking for hardware initialization and communication. Implement diagnostic modes that report system health and component status.

    \item \textbf{PWM LED Control:} Instead of simple on/off control, implement PWM-based brightness control to allow gradual fade-in/fade-out effects or multiple brightness levels.

    \item \textbf{Timing Improvements:} Use non-blocking timing with \texttt{millis()} instead of \texttt{delay()} to allow concurrent operation of multiple tasks without blocking.
\end{itemize}

\subsection*{4.4. Knowledge Gained}

Through this laboratory work, I gained practical experience with:

\begin{itemize}
    \item Setting up and using the PlatformIO development environment for embedded systems.
    \item Understanding the architecture of embedded systems and the importance of hardware-software interfaces.
    \item Implementing GPIO control for both input (button) and output (LED) operations.
    \item Working with serial communication (UART) and STDIO redirection for user interaction.
    \item Implementing software debouncing to handle mechanical switch characteristics.
    \item Creating modular code with clear separation between drivers and application logic.
    \item Debugging embedded systems through serial output and hardware observation.
\end{itemize}

\subsection*{4.5. Real-World Applications}

The techniques learned in this laboratory work are directly applicable to numerous real-world embedded systems:

\begin{itemize}
    \item \textbf{Consumer Electronics:} TV remote controls, microwave ovens, and washing machines all use buttons for user input and LEDs for status indication.

    \item \textbf{Industrial Control:} Control panels with emergency stop buttons and status LEDs are common in manufacturing environments.

    \item \textbf{Automotive:} Dashboard controls, steering wheel buttons, and indicator lights follow similar principles.

    \item \textbf{IoT Devices:} Smart home devices often include buttons for manual control and LEDs for status feedback, with serial communication for setup and diagnostics.

    \item \textbf{Medical Devices:} Patient monitoring equipment and medical instruments use buttons for user interaction and LEDs for alerts and status.
\end{itemize}

The foundational concepts learned here—GPIO control, serial communication, hardware-software interfaces, and modular design—are essential skills for embedded systems engineering and provide a solid foundation for more complex projects.

% ============================================================================
% CHAPTER 5: AI TOOLS USAGE
% ============================================================================
\section*{5. Note on AI Tools Usage}

During the preparation of this report, the author utilized ChatGPT (an AI language model developed by OpenAI) for generating and consolidating content. The AI assistance was used for:

\begin{itemize}
    \item Generating and structuring technical descriptions of hardware components and technologies.
    \item Formulating explanations of system architecture and design decisions.
    \item Drafting sections on domain analysis and case studies.
    \item Suggesting improvements and limitations based on the implemented solution.
    \item Assisting with formatting and organizing the report structure.
\end{itemize}

All information generated by the AI tool was reviewed, validated, and adjusted by the author to ensure accuracy, relevance, and compliance with the laboratory work requirements. The author takes full responsibility for the content presented in this report.

% ============================================================================
% CHAPTER 6: BIBLIOGRAPHY
% ============================================================================
\section*{6. Bibliography}

\begin{enumerate}
    \item Arduino.cc. \textit{Arduino Language Reference}. Available: \url{https://www.arduino.cc/reference/en/} [Accessed: 2026-02-08].

    \item Atmel Corporation. \textit{ATmega2560 Datasheet - Complete}. 2014. Available: \url{https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf} [Accessed: 2026-02-08].

    \item PlatformIO. \textit{PlatformIO Documentation}. Available: \url{https://docs.platformio.org/} [Accessed: 2026-02-08].

    \item Texas Instruments. \textit{Understanding and Minimizing ADC Conversion Errors}. Application Report SLOA099, 2018.

    \item Axelson, J. \textit{Serial Port Complete: COM Ports, USB Virtual COM Ports, and Ports for Embedded Systems}. Lakeview Research, 2007.
\end{enumerate}

% ============================================================================
% CHAPTER 7: APPENDIX - SOURCE CODE
% ============================================================================
\section*{7. Appendix - Source Code}

\subsection*{7.1. LED Driver Header (led.h)}

\begin{lstlisting}[language=C++, caption=led.h - LED Driver Interface]
#ifndef LED_H
#define LED_H

#include <Arduino.h>

class Led
{
public:
	explicit Led(uint8_t pin);
	void begin();
	void on();
	void off();
	void toggle();
	bool state() const;

private:
	uint8_t _pin;
	bool _state;
};

#endif // LED_H
\end{lstlisting}

